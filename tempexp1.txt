grammar ppl4450;

tokens { INDENT, DEDENT }

@lexer::members {
    private java.util.LinkedList<Token> tokens = new java.util.LinkedList<>();
    private java.util.Stack<Integer> indents = new java.util.Stack<>();
    private Token lastToken = null;

    @Override
    public void emit(Token t) {
        super.setToken(t);
        tokens.offer(t);
    }

    @Override
    public Token nextToken() {
        if (_input.LA(1) == EOF && !indents.isEmpty()) {
            this.emit(commonToken(ppl4450Parser.NEWLINE, "\n"));
            while (!indents.isEmpty()) {
                this.emit(createDedent());
                indents.pop();
            }
            this.emit(commonToken(ppl4450Parser.EOF, "<EOF>"));
        }

        Token next = super.nextToken();
        if (next.getChannel() == Token.DEFAULT_CHANNEL) {
            this.lastToken = next;
        }
        return tokens.isEmpty() ? next : tokens.poll();
    }

    private Token createDedent() {
        CommonToken dedent = commonToken(ppl4450Parser.DEDENT, "");
        dedent.setLine(this.lastToken.getLine());
        return dedent;
    }

    private CommonToken commonToken(int type, String text) {
        int stop = this.getCharIndex() - 1;
        int start = text.isEmpty() ? stop : stop - text.length() + 1;
        return new CommonToken(this._tokenFactorySourcePair, type, DEFAULT_TOKEN_CHANNEL, start, stop);
    }

    static int getIndentationCount(String spaces) {
        int count = 0;
        for (char ch : spaces.toCharArray()) {
            switch (ch) {
                case '\t':
                    count += 8 - (count % 8);
                    break;
                default:
                    count++;
            }
        }
        return count;
    }

    boolean atStartOfInput() {
        return super.getCharPositionInLine() == 0 && super.getLine() == 1;
    }
}

// Start Rule
program : (single_input)+;
single_input
    : NEWLINE
    | simple_stmt
    | compound_stmt NEWLINE
    ;

// Supporting Rules
simple_stmt
    : assignment
    ;

compound_stmt
    : if
    ;

operation
    : assignment
    | expression
    | compound_stmt
    ;

assignment
    : ID NEWLINE? (EQU | EQU_P | EQU_MI | EQU_MU | EQU_D) NEWLINE? expression
    ;

expression
    : logical
    ;

logical
    : comparison ((NEWLINE? AND NEWLINE? comparison) | (NEWLINE? OR NEWLINE? comparison))*
    ;

comparison
    : addition ((NEWLINE? (CLT | CGT | CLTE | CGTE | CEQU | CNEQU) NEWLINE? addition))*
    ;

addition
    : multiplication ((NEWLINE? (PLU | MIN) NEWLINE? multiplication))*
    ;

multiplication
    : primary ((NEWLINE? (MUL | DIV | MOD) NEWLINE? primary))*
    ;

primary
    : PAR_O NEWLINE? expression NEWLINE? PAR_C
    | ID
    | INT
    | FLO
    | STR
    | BOOL
    ;

if
    : IF NEWLINE? expression NEWLINE? COL NEWLINE
      INDENT (operation NEWLINE?)+ DEDENT
      (ELIF NEWLINE? expression NEWLINE? COL NEWLINE
       INDENT (operation NEWLINE?)+ DEDENT)*
      (ELSE COL NEWLINE
       INDENT (operation NEWLINE?)+ DEDENT)?
    ;

// Lexer Rules
NEWLINE
    : ({atStartOfInput()}? SPACES
      | ('\r'? '\n' | '\r') SPACES?)
      {
          String newLine = getText().replaceAll("[^\r\n]+", "");
          String spaces = getText().replaceAll("[\r\n]+", "");
          int next = _input.LA(1);

          if (opened > 0 || next == '\r' || next == '\n' || next == '#') {
              skip();
          } else {
              emit(commonToken(ppl4450Parser.NEWLINE, newLine));
              int indent = getIndentationCount(spaces);
              int previous = indents.isEmpty() ? 0 : indents.peek();

              if (indent == previous) {
                  skip();
              } else if (indent > previous) {
                  indents.push(indent);
                  emit(commonToken(ppl4450Parser.INDENT, spaces));
              } else {
                  while (!indents.isEmpty() && indents.peek() > indent) {
                      this.emit(createDedent());
                      indents.pop();
                  }
              }
          }
      }
    ;

SPACES
    : [ \t]+ -> skip;  // Fragment rule, does not generate a token

PLU     : '+';
MIN     : '-';
MUL     : '*';
DIV     : '/';
MOD     : '%';
IF      : 'if';
ELIF    : 'elif';
ELSE    : 'else';
EQU     : '=';
EQU_P   : '+=';
EQU_MI  : '-=';
EQU_MU  : '*=';
EQU_D   : '/=';
CLT     : '<';
CGT     : '>';
CLTE    : '<=';
CGTE    : '>=';
CEQU    : '==';
CNEQU   : '!=';
AND     : 'and';
OR      : 'or';
NOT     : 'not';
BRA_O   : '[';
BRA_C   : ']';
PAR_O   : '(';
PAR_C   : ')';
COM     : ',';
COL     : ':';
ID      : [a-zA-Z_][a-zA-Z_0-9]*;
STR     : '\'' (~['\r\n])* '\''
        | '"' (~["\r\n])* '"';
INT     : [+-]? [0-9]+;
FLO     : [+-]? [0-9]+ '.' [0-9]+ | [+-]? '.' [0-9]+;
BOOL    : 'True' | 'False';
